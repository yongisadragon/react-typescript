<!DOCTYPE html>
<html lang="ko-KR">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>test</title>
  </head>
  <body>
    <h2>테스트</h2>
    <script src="class.js">
      // 프로토타입 기억안나서 간단하게 짚고 넘어가자. class의 프로토타입은 원형이라고 뜻이 나오지만,, class나 함수의 '유전자'라고 기억하면 쉽다..

      function 기계(q, w) {
        this.q = q;
        this.w = w;
      }
      // 이렇게 생성자 함수(부모 자식 개념)를 통해 object가 생성됨. 콘솔에 nunu 찍어보면 파라미터로 들어간게 기계라는 함수(object)로 잘 출력될것임..
      const nunu = new 기계("q스킬", "w스킬");

      // 기계.prototype이라고 콘솔 찍어보면 object 가 나온다. 기계 함수의 원형, 유전자가 기록되는 obj가 나오는 것이다. 오브젝트 자료이기 때문에 이런 식으로 요소도 추가할 수 있는데.. 이러면 자식들(nunu)도 이것을 사용가능함.
      기계.prototype.name = "상용";

      // 그래서 nunu.name을 하면 '상용'나옴. obj에서 자료를 뽑아낼때 일어나는 일은 1.직접 자료 가지고 있으면 그거 출력. 2. 없으면 부모유전자까지 뒤짐. 3. 없으면 부모의 부모.. 이걸 prototype chain어쩌구..라고함
      // 그래서 이 원리를 알면.. 배열에 .sort() , .length등을 붙여서 사용할 수 있는 이유가 설명됨. 어레이를 생성할 때에도 컴퓨터는 new Arraay(...) 이런식으로 생성하기 때문.. Array부모 유전자에 기록된 메서드들이기 때문임.
      // 말마따나 이런식으로 수정하면 언제든 쓸수있는 함수(메서드)가 생성됨.
      Array.prototype.새함수 = function () {
        console.log("새함수");
      };
    </script>
  </body>
</html>
